const libPictProvider = require('pict-provider');

// TODO: Pull this back to pict as a core service once we are happy with the shape.
/** @type {Record<string, any>} */
const _DefaultProviderConfiguration = (
{
	"ProviderIdentifier": "Pict-DynamicForms-SolverBehaviors",

	"AutoInitialize": false,
	"AutoInitializeOrdinal": 0,
	"AutoSolveWithApp": false
});

/**
 * Provides functions available in the solver for manipulating the form.
 * Such as showing/hiding sections, inputs, groups.  Coloring inputs,
 * sections, groups.  Applying styles to inputs, sections, groups.
 * Extends the `libPictProvider` class.
 */
class PictDynamicFormsSolverBehaviors extends libPictProvider
{
	/**
	 * Creates an instance of the `PictDynamicFormsInformary` class.
	 * @param {object} pFable - The fable object.
	 * @param {object} pOptions - The options object.
	 * @param {object} pServiceHash - The service hash object.
	 */
	constructor(pFable, pOptions, pServiceHash)
	{
		let tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(_DefaultProviderConfiguration)), pOptions);

		super(pFable, tmpOptions, pServiceHash);

		/** @type {any} */
		this.options;
		/** @type {import('pict') & { newManyfest: (options: any) => import('manyfest') }} */
		this.pict;
		/** @type {any} */
		this.log;

		/** @type {string} */
		this.cssHideSectionClass = 'pict-section-form-hidden-section';
		this.cssHideGroupClass = 'pict-section-form-hidden-group';
		this.cssSnippet = '.pict-section-form-hidden-section { display: none; } .pict-section-form-hidden-group { display: none; }';

		this.setCSSSnippets();
	}

	setCSSSnippets(pCSSHideClass, pCSSSnippet)
	{
		this.cssHideClass = pCSSHideClass || this.cssHideClass;
		this.cssSnippet = pCSSSnippet || this.cssSnippet;
		this.pict.CSSMap.addCSS('Pict-Section-Form-SolverBehaviors', this.cssSnippet, 1001, 'Pict-DynamicForm-SolverBehaviors');
		this.pict.CSSMap.injectCSS();
	}

	addSolverFunction(pExpressionParser, pFunctionName, pFunctionAddress, pFunctionComment)
	{
		let tmpFunctionName = (pFunctionName || '').trim().toLowerCase();
		if (pExpressionParser.functionMap.hasOwnProperty(tmpFunctionName))
		{
			this.log.warn(`PictDynamicFormsInformary: Function ${tmpFunctionName} already exists in the solver, overwriting with address [${pFunctionAddress}].`);
			//return false;
		}
		pExpressionParser.functionMap[tmpFunctionName] = (
		{
			Name: pFunctionComment || `Autogenerated function ${tmpFunctionName}`,
			Address: pFunctionAddress,
		});
	}

	injectBehaviors(pExpressionParser)
	{
		// Wire up the solver functions.
		this.addSolverFunction(pExpressionParser, 'logValues', 'fable.providers.DynamicFormSolverBehaviors.logValues', 'Logs a set of values to the console and returns the last one.');

		this.addSolverFunction(pExpressionParser, 'setSectionVisibility', 'fable.providers.DynamicFormSolverBehaviors.setSectionVisibility', 'Sets a sections visiblity to true or fales based on the second parameter.');
		this.addSolverFunction(pExpressionParser, 'setGroupVisibility', 'fable.providers.DynamicFormSolverBehaviors.setGroupVisibility', 'Sets a group visiblity to true or fales based on the third parameter.');

		this.addSolverFunction(pExpressionParser, 'generateHTMLHexColor', 'fable.providers.DynamicFormSolverBehaviors.generateHTMLHexColor', 'Generates a HTML hex color from three integer parameters (red, green, blue).');

		this.addSolverFunction(pExpressionParser, 'colorSectionBackground', 'fable.providers.DynamicFormSolverBehaviors.colorSectionBackground', 'Colors a section background with a HTML hex color (e.g. #FF0000 for red).');
		this.addSolverFunction(pExpressionParser, 'colorGroupBackground', 'fable.providers.DynamicFormSolverBehaviors.colorGroupBackground', 'Colors a group background with a HTML hex color (e.g. #FF0000 for red).');
		this.addSolverFunction(pExpressionParser, 'colorInputBackground', 'fable.providers.DynamicFormSolverBehaviors.colorInputBackground', 'Colors an input background with a HTML hex color (e.g. #FF0000 for red).');

		return false;
	}

	getSectionSelector(pSectionFormID)
	{
		return `#SECTION-${pSectionFormID}`;
	}

	setSectionVisibility(pSectionHash, pVisible)
	{
		if (pVisible != "0")
		{
			return this.showSection(pSectionHash);
		}
		else
		{
			return this.hideSection(pSectionHash);
		}
	}

	/* THESE DO NOT BELONG HERE BUT THIS WORKS FOR NOW */
	hideSection(pSectionHash)
	{
		let tmpSectionView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpSectionView)
		{
			this.log.warn(`PictDynamicFormsInformary: hideSection could not find section with hash [${pSectionHash}].`);
			return false;
		}

		if (this.pict.ContentAssignment.hasClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass))
		{
			// Already hidden.
			return true;
		}

		this.pict.ContentAssignment.addClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass);
		return true;
	}

	showSection(pSectionHash)
	{
		let tmpSectionView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpSectionView)
		{
			this.log.warn(`PictDynamicFormsInformary: showSection could not find section with hash [${pSectionHash}].`);
			return false;
		}

		if (!this.pict.ContentAssignment.hasClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass))
		{
			// Already visible.
			return true;
		}

		this.pict.ContentAssignment.removeClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass);
		return true;
	}

	getGroupSelector(pSectionFormID, pGroupHash)
	{
		return `#GROUP-${pSectionFormID}-${pGroupHash}`;
	}

	setGroupVisibility(pSectionHash, pGroupHash, pVisible)
	{
		if (pVisible)
		{
			return this.showGroup(pSectionHash, pGroupHash);
		}
		else
		{
			return this.hideGroup(pSectionHash, pGroupHash);
		}
	}

	hideGroup(pSectionHash, pGroupHash)
	{
		let tmpGroupView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpGroupView)
		{
			this.log.warn(`PictDynamicFormsInformary: hideGroup could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		if (this.pict.ContentAssignment.hasClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass))
		{
			// Already hidden.
			return true;
		}

		this.pict.ContentAssignment.addClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass);
		return true;
	}

	showGroup(pSectionHash, pGroupHash)
	{
		let tmpGroupView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpGroupView)
		{
			this.log.warn(`PictDynamicFormsInformary: showGroup could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		if (!this.pict.ContentAssignment.hasClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass))
		{
			// Already visible.
			return true;
		}

		this.pict.ContentAssignment.removeClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass);
		return true;
	}

	generateHTMLHexColor(pRed, pGreen, pBlue)
	{
		let tmpRed = (parseInt(pRed) || 0);
		let tmpGreen = (parseInt(pGreen) || 0);
		let tmpBlue = (parseInt(pBlue) || 0);

		if (tmpRed < 0) { tmpRed = 0; }
		if (tmpRed > 255) { tmpRed = 255; }
		if (tmpGreen < 0) { tmpGreen = 0; }
		if (tmpGreen > 255) { tmpGreen = 255; }
		if (tmpBlue < 0) { tmpBlue = 0; }
		if (tmpBlue > 255) { tmpBlue = 255; }

		let tmpRedHex = tmpRed.toString(16).toUpperCase();
		if (tmpRedHex.length < 2) { tmpRedHex = `0${tmpRedHex}`; }
		let tmpGreenHex = tmpGreen.toString(16).toUpperCase();
		if (tmpGreenHex.length < 2) { tmpGreenHex = `0${tmpGreenHex}`; }
		let tmpBlueHex = tmpBlue.toString(16).toUpperCase();
		if (tmpBlueHex.length < 2) { tmpBlueHex = `0${tmpBlueHex}`; }

		return `#${tmpRedHex}${tmpGreenHex}${tmpBlueHex}`;
	}

	colorSectionBackground(pSectionHash, pColor, pApplyChange)
	{
		if (pApplyChange == "0")
		{
			return true;
		}

		let tmpSectionView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpSectionView)
		{
			this.log.warn(`PictDynamicFormsInformary: colorSection could not find section with hash [${pSectionHash}].`);
			return false;
		}

		let tmpElementSet = this.pict.ContentAssignment.getElement(this.getSectionSelector(tmpSectionView.formID));

		if (tmpElementSet.length < 1)
		{
			this.log.warn(`PictDynamicFormsInformary: colorSection could not find section element with hash [${pSectionHash}] selector [${this.getSectionSelector(tmpSectionView.formID)}].`);
			return false;
		}

		let tmpElement = tmpElementSet[0];

		tmpElement.style.backgroundColor = pColor;

		return true;
	}

	colorGroupBackground(pSectionHash, pGroupHash, pColor, pApplyChange)
	{
		if (pApplyChange == "0")
		{
			return true;
		}

		let tmpGroupView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpGroupView)
		{
			this.log.warn(`PictDynamicFormsInformary: colorGroup could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		let tmpElementSet = this.pict.ContentAssignment.getElement(this.getGroupSelector(tmpGroupView.formID, pGroupHash));
		
		if (tmpElementSet.length < 1)
		{
			this.log.warn(`PictDynamicFormsInformary: colorGroup could not find group element with section hash [${pSectionHash}] group [${pGroupHash}] selector [${this.getGroupSelector(tmpGroupView.formID, pGroupHash)}].`);
			return false;
		}

		let tmpElement = tmpElementSet[0];
		tmpElement.style.backgroundColor = pColor;

		return true;
	}

	colorInputBackground(pSectionHash, pInputHash, pColor, pApplyChange)
	{
		if (pApplyChange == "0")
		{
			return true;
		}

		let tmpInputView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)

		if (!tmpInputView)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInput could not find input with section hash [${pSectionHash}] input [${pInputHash}].`);
			return false;
		}

		let tmpInput = tmpInputView.getInputFromHash(pInputHash);

		if (!tmpInput)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInput could not find input with section hash [${pSectionHash}] input [${pInputHash}].`);
			return false;
		}

		let tmpElementSet = this.pict.ContentAssignment.getElement(`#INPUT-${tmpInput.Macro.RawHTMLID}`);

		if (tmpElementSet.length < 1)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInput could not find input element with section hash [${pSectionHash}] input [${pInputHash}] selector [#INPUT-${tmpInput.Macro.RawHTMLID}].`);
			return false;
		}

		let tmpElement = tmpElementSet[0];
		tmpElement.style.backgroundColor = pColor;

		return true;
	}

	logValues()
	{
		let tmpLastValue = null;
		let tmpLogLine = 'Solver logvalues call: ';
		for (let i = 0; i < arguments.length; i++)
		{
			tmpLastValue = arguments[i];
			tmpLogLine += `  [${i}]=[${tmpLastValue}]`;
		}
		this.log.info(tmpLogLine);
		return tmpLastValue;
	}
}

module.exports = PictDynamicFormsSolverBehaviors;
module.exports.default_configuration = _DefaultProviderConfiguration;
