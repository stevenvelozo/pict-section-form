const libPictProvider = require('pict-provider');

// TODO: Pull this back to pict as a core service once we are happy with the shape.
/** @type {Record<string, any>} */
const _DefaultProviderConfiguration = (
{
	"ProviderIdentifier": "Pict-DynamicForms-SolverBehaviors",

	"AutoInitialize": false,
	"AutoInitializeOrdinal": 0,
	"AutoSolveWithApp": false
});

/**
 * Provides functions available in the solver for manipulating the form.
 * Such as showing/hiding sections, inputs, groups.  Coloring inputs,
 * sections, groups.  Applying styles to inputs, sections, groups.
 * Extends the `libPictProvider` class.
 */
class PictDynamicFormsSolverBehaviors extends libPictProvider
{
	/**
	 * Creates an instance of the `PictDynamicFormsInformary` class.
	 *
	 * @param {import('fable')} pFable - The Fable instance.
	 * @param {Record<string, any>} [pOptions] - The options for the provider.
	 * @param {string} [pServiceHash] - The service hash for the provider.
	 */
	constructor(pFable, pOptions, pServiceHash)
	{
		let tmpOptions = Object.assign({}, JSON.parse(JSON.stringify(_DefaultProviderConfiguration)), pOptions);

		super(pFable, tmpOptions, pServiceHash);

		/** @type {any} */
		this.options;
		/** @type {import('pict') & { newManyfest: (options: any) => import('manyfest') }} */
		this.pict;
		/** @type {any} */
		this.log;

		/** @type {string} */
		this.cssHideSectionClass = 'pict-section-form-hidden-section';
		this.cssHideGroupClass = 'pict-section-form-hidden-group';
		this.cssSnippet = '.pict-section-form-hidden-section { display: none; } .pict-section-form-hidden-group { display: none; }';

		this.solverOrdinalMap = {};

		this.setCSSSnippets();
	}

	setCSSSnippets(pCSSHideClass, pCSSSnippet)
	{
		this.cssHideClass = pCSSHideClass || this.cssHideClass;
		this.cssSnippet = pCSSSnippet || this.cssSnippet;
		this.pict.CSSMap.addCSS('Pict-Section-Form-SolverBehaviors', this.cssSnippet, 1001, 'Pict-DynamicForm-SolverBehaviors');
		this.pict.CSSMap.injectCSS();
	}

	addSolverFunction(pExpressionParser, pFunctionName, pFunctionAddress, pFunctionComment)
	{
		let tmpFunctionName = (pFunctionName || '').trim().toLowerCase();
		if (pExpressionParser.functionMap.hasOwnProperty(tmpFunctionName))
		{
			this.log.warn(`PictDynamicFormsInformary: Function ${tmpFunctionName} already exists in the solver, overwriting with address [${pFunctionAddress}].`);
			//return false;
		}
		pExpressionParser.functionMap[tmpFunctionName] = (
		{
			Name: pFunctionComment || `Autogenerated function ${tmpFunctionName}`,
			Address: pFunctionAddress,
		});
	}

	runSolvers()
	{
		const tmpViewHashes = this.pict.providers.DynamicSolver.solveViews(undefined, true);
		/* TODO: since this is always run from a solve, I don't think we need to do an extra marshal here
		if (this.pict.views.PictFormMetacontroller)
		{
			this.pict.views.PictFormMetacontroller.marshalFormSections();
		}
		else
		{
			for (let i = 0; i < tmpViewHashes.length; i++)
			{
				const tmpViewHash = tmpViewHashes[i];
				this.pict.views[tmpViewHash]?.marshalToView?.();
			}
		}
		*/
	}

	injectBehaviors(pExpressionParser)
	{
		// Wire up the solver functions.
		this.addSolverFunction(pExpressionParser, 'logvalues', 'fable.providers.DynamicFormSolverBehaviors.logValues', 'Logs a set of values to the console and returns the last one.');

		this.addSolverFunction(pExpressionParser, 'setsectionvisibility', 'fable.providers.DynamicFormSolverBehaviors.setSectionVisibility', 'Sets a sections visiblity to true or fales based on the second parameter.');
		this.addSolverFunction(pExpressionParser, 'setgroupvisibility', 'fable.providers.DynamicFormSolverBehaviors.setGroupVisibility', 'Sets a group visiblity to true or fales based on the third parameter.');

		this.addSolverFunction(pExpressionParser, 'generatehtmlhexcolor', 'fable.providers.DynamicFormSolverBehaviors.generateHTMLHexColor', 'Generates a HTML hex color from three integer parameters (red, green, blue).');

		this.addSolverFunction(pExpressionParser, 'colorsectionbackground', 'fable.providers.DynamicFormSolverBehaviors.colorSectionBackground', 'Colors a section background with a HTML hex color (e.g. #FF0000 for red).');
		this.addSolverFunction(pExpressionParser, 'colorgroupbackground', 'fable.providers.DynamicFormSolverBehaviors.colorGroupBackground', 'Colors a group background with a HTML hex color (e.g. #FF0000 for red).');
		this.addSolverFunction(pExpressionParser, 'colorinputbackground', 'fable.providers.DynamicFormSolverBehaviors.colorInputBackground', 'Colors an input background with a HTML hex color (e.g. #FF0000 for red).');
		this.addSolverFunction(pExpressionParser, 'colorinputbackgroundtabular', 'fable.providers.DynamicFormSolverBehaviors.colorInputBackgroundTabular', 'Colors a tabular input background with a HTML hex color (e.g. #FF0000 for red).');

		this.addSolverFunction(pExpressionParser, 'setsolverordinalenabled', 'fable.providers.DynamicFormSolverBehaviors.setSolverOrdinalEnabled', 'Enables or disabled a solver ordinal to determine if it should run.');
		this.addSolverFunction(pExpressionParser, 'enablesolverordinal', 'fable.providers.DynamicFormSolverBehaviors.enableSolverOrdinal', 'Enables a solver ordinal so that it can run.');
		this.addSolverFunction(pExpressionParser, 'disablesolverordinall', 'fable.providers.DynamicFormSolverBehaviors.disableSolverOrdinal', 'Disables a solver ordinal so that it will not run.');

		this.addSolverFunction(pExpressionParser, 'settabularrowlength', 'fable.providers.DynamicFormSolverBehaviors.setTabularRowLength', 'Sets the length of a tabular data set.');
		this.addSolverFunction(pExpressionParser, 'runsolvers', 'fable.providers.DynamicFormSolverBehaviors.runSolvers', 'Solves all views.');

		return false;
	}

	/**
	 * @param {number|string} pSolverOrdinal
	 * @param {boolean|string|number} pEnabled
	 */
	setSolverOrdinalEnabled(pSolverOrdinal, pEnabled)
	{
		this.solverOrdinalMap[`ORD-${pSolverOrdinal}`] = pEnabled == true || pEnabled == '1';
	}

	/**
	 * @param {number|string} pSolverOrdinal
	 */
	enableSolverOrdinal(pSolverOrdinal)
	{
		this.solverOrdinalMap[`ORD-${pSolverOrdinal}`] = true;
	}

	/**
	 * @param {number|string} pSolverOrdinal
	 */
	disableSolverOrdinal(pSolverOrdinal)
	{
		this.solverOrdinalMap[`ORD-${pSolverOrdinal}`] = false;
	}

	/**
	 * @param {number|string} pSolveOrdinal
	 *
	 * @return {boolean}
	 */
	checkSolverOrdinalEnabled(pSolveOrdinal)
	{
		let tmpOrdinalKey = `ORD-${pSolveOrdinal}`;
		return (!(tmpOrdinalKey in this.solverOrdinalMap)) || (this.solverOrdinalMap[tmpOrdinalKey] === true);
	}

	getSectionSelector(pSectionFormID)
	{
		return `#SECTION-${pSectionFormID}`;
	}

	setSectionVisibility(pSectionHash, pVisible)
	{
		if (pVisible != "0")
		{
			return this.showSection(pSectionHash);
		}
		else
		{
			return this.hideSection(pSectionHash);
		}
	}

	/* THESE DO NOT BELONG HERE BUT THIS WORKS FOR NOW */
	hideSection(pSectionHash)
	{
		let tmpSectionView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpSectionView)
		{
			this.log.warn(`PictDynamicFormsInformary: hideSection could not find section with hash [${pSectionHash}].`);
			return false;
		}

		if (this.pict.ContentAssignment.hasClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass))
		{
			// Already hidden.
			return true;
		}

		this.pict.ContentAssignment.addClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass);
		return true;
	}

	showSection(pSectionHash)
	{
		let tmpSectionView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpSectionView)
		{
			this.log.warn(`PictDynamicFormsInformary: showSection could not find section with hash [${pSectionHash}].`);
			return false;
		}

		if (!this.pict.ContentAssignment.hasClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass))
		{
			// Already visible.
			return true;
		}

		this.pict.ContentAssignment.removeClass(this.getSectionSelector(tmpSectionView.formID), this.cssHideSectionClass);
		return true;
	}

	getGroupSelector(pSectionFormID, pGroupHash)
	{
		return `#GROUP-${pSectionFormID}-${pGroupHash}`;
	}

	setGroupVisibility(pSectionHash, pGroupHash, pVisible)
	{
		if (pVisible != "0")
		{
			return this.showGroup(pSectionHash, pGroupHash);
		}
		else
		{
			return this.hideGroup(pSectionHash, pGroupHash);
		}
	}

	hideGroup(pSectionHash, pGroupHash)
	{
		let tmpGroupView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpGroupView)
		{
			this.log.warn(`PictDynamicFormsInformary: hideGroup could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		if (this.pict.ContentAssignment.hasClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass))
		{
			// Already hidden.
			return true;
		}

		this.pict.ContentAssignment.addClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass);
		return true;
	}

	showGroup(pSectionHash, pGroupHash)
	{
		let tmpGroupView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpGroupView)
		{
			this.log.warn(`PictDynamicFormsInformary: showGroup could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		if (!this.pict.ContentAssignment.hasClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass))
		{
			// Already visible.
			return true;
		}

		this.pict.ContentAssignment.removeClass(this.getGroupSelector(tmpGroupView.formID, pGroupHash), this.cssHideGroupClass);
		return true;
	}

	/**
	 * Set the length of a tabular set
	 * @param {string} pSectionHash - The hash of the section containing the tabular group
	 * @param {string} pGroupHash - The hash of the tabular group
	 * @param {number|string} pLength - The desired length of the tabular set
	 * @param {boolean|string} pDeleteExtraRows - If true, will delete extra rows from the end if the length is less than current 
	 * @returns 
	 */
	setTabularRowLength(pSectionHash, pGroupHash, pLength, pDeleteExtraRows = false)
	{
		let tmpGroupView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpGroupView)
		{
			this.log.warn(`PictDynamicFormsInformary: showGroup could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}
		let tmpGroupIndex = tmpGroupView.getGroupIndexFromHash(pGroupHash);
		if (tmpGroupIndex < 0)
		{
			this.log.warn(`PictDynamicFormsInformary: setTabularRowLength could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}
		let tmpTabularRecordSet = tmpGroupView.getTabularRecordSet(tmpGroupIndex);
		if (!tmpTabularRecordSet || !Array.isArray(tmpTabularRecordSet))
		{
			this.log.warn(`PictDynamicFormsInformary: setTabularRowLength could not find a valid tabular record set with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		let tmpLength = parseInt(pLength.toString());
		if (isNaN(tmpLength) || tmpLength < 0)
		{
			this.log.warn(`PictDynamicFormsInformary: setTabularRowLength was given an invalid length [${pLength}] with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		// See if the length is less than what we have
		let tmpCurrentLength = tmpTabularRecordSet.length;

		let tmpDeleteExtraRows = (pDeleteExtraRows == true || pDeleteExtraRows == '1');

		if (tmpLength > tmpCurrentLength)
		{
			// Add rows until we are at the expected length
			for (let i = tmpCurrentLength; i < tmpLength; i++)
			{
				tmpGroupView.createDynamicTableRow(tmpGroupIndex);
			}
		}
		else if (tmpLength < tmpCurrentLength && tmpDeleteExtraRows)
		{
			// Remove rows from the end until we are at the expected length
			for (let i = tmpCurrentLength - 1; i >= tmpLength; i--)
			{
				tmpGroupView.deleteDynamicTableRow(tmpGroupIndex, i);
			}
		}
	}


	generateHTMLHexColor(pRed, pGreen, pBlue)
	{
		let tmpRed = (parseInt(pRed) || 0);
		let tmpGreen = (parseInt(pGreen) || 0);
		let tmpBlue = (parseInt(pBlue) || 0);

		if (tmpRed < 0) { tmpRed = 0; }
		if (tmpRed > 255) { tmpRed = 255; }
		if (tmpGreen < 0) { tmpGreen = 0; }
		if (tmpGreen > 255) { tmpGreen = 255; }
		if (tmpBlue < 0) { tmpBlue = 0; }
		if (tmpBlue > 255) { tmpBlue = 255; }

		let tmpRedHex = tmpRed.toString(16).toUpperCase();
		if (tmpRedHex.length < 2) { tmpRedHex = `0${tmpRedHex}`; }
		let tmpGreenHex = tmpGreen.toString(16).toUpperCase();
		if (tmpGreenHex.length < 2) { tmpGreenHex = `0${tmpGreenHex}`; }
		let tmpBlueHex = tmpBlue.toString(16).toUpperCase();
		if (tmpBlueHex.length < 2) { tmpBlueHex = `0${tmpBlueHex}`; }

		return `#${tmpRedHex}${tmpGreenHex}${tmpBlueHex}`;
	}

	colorSectionBackground(pSectionHash, pColor, pApplyChange)
	{
		if (pApplyChange == "0")
		{
			return true;
		}

		let tmpSectionView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpSectionView)
		{
			this.log.warn(`PictDynamicFormsInformary: colorSection could not find section with hash [${pSectionHash}].`);
			return false;
		}

		let tmpElementSet = this.pict.ContentAssignment.getElement(this.getSectionSelector(tmpSectionView.formID));

		if (tmpElementSet.length < 1)
		{
			this.log.warn(`PictDynamicFormsInformary: colorSection could not find section element with hash [${pSectionHash}] selector [${this.getSectionSelector(tmpSectionView.formID)}].`);
			return false;
		}

		let tmpElement = tmpElementSet[0];

		tmpElement.style.backgroundColor = pColor;

		return true;
	}

	colorGroupBackground(pSectionHash, pGroupHash, pColor, pApplyChange)
	{
		if (pApplyChange == "0")
		{
			return true;
		}

		let tmpGroupView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash)
		if (!tmpGroupView)
		{
			this.log.warn(`PictDynamicFormsInformary: colorGroup could not find group with section hash [${pSectionHash}] group [${pGroupHash}].`);
			return false;
		}

		let tmpElementSet = this.pict.ContentAssignment.getElement(this.getGroupSelector(tmpGroupView.formID, pGroupHash));

		if (tmpElementSet.length < 1)
		{
			this.log.warn(`PictDynamicFormsInformary: colorGroup could not find group element with section hash [${pSectionHash}] group [${pGroupHash}] selector [${this.getGroupSelector(tmpGroupView.formID, pGroupHash)}].`);
			return false;
		}

		let tmpElement = tmpElementSet[0];
		tmpElement.style.backgroundColor = pColor;

		return true;
	}

	/**
	 * Colors an input background or its container with a HTML hex color (e.g. #FF0000 for red).
	 * @param {string} pSectionHash - The hash of the section containing the input.
	 * @param {string} pInputHash - The hash of the input to color.
	 * @param {string} pColor - The HTML hex color to apply (e.g. #FF0000 for red).
	 * @param {string} pApplyChange - If "0", the change will not be applied.
	 * @param {string} [pCSSSelector] - Optional. If provided, the color will be applied to the closest element matching this selector instead of the input itself.
	 * @returns {boolean} - Returns true if the color was applied successfully or if the change was skipped for pApplyChange equal to "0", false otherwise.
	 */
	colorInputBackground(pSectionHash, pInputHash, pColor, pApplyChange, pCSSSelector)
	{
		if (pApplyChange == "0")
		{
			return true;
		}

		/** @type {import('../views/Pict-View-DynamicForm.js')} */
		let tmpInputView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash);

		if (!tmpInputView)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInput could not find input with section hash [${pSectionHash}] input [${pInputHash}].`);
			return false;
		}

		let tmpInput = tmpInputView.getInputFromHash(pInputHash);

		if (!tmpInput)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInput could not find input with section hash [${pSectionHash}] input [${pInputHash}].`);
			return false;
		}

		let tmpElementSet = this.pict.ContentAssignment.getElement(`#${tmpInput.Macro.RawHTMLID}`);

		if (tmpElementSet.length < 1)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInput could not find input element with section hash [${pSectionHash}] input [${pInputHash}] selector [#${tmpInput.Macro.RawHTMLID}].`);
			return false;
		}

		return this.colorElementBackground(tmpElementSet, pColor, pCSSSelector);
	}

	/**
	 * Colors an input background or its container with a HTML hex color (e.g. #FF0000 for red).
	 * @param {string} pSectionHash - The hash of the section containing the input.
	 * @param {string} pGroupHash - The hash of the group containing the input.
	 * @param {number} pRowIndex - The index of the row.
	 * @param {string} pInputHash - The hash of the input to color.
	 * @param {string} pColor - The HTML hex color to apply (e.g. #FF0000 for red).
	 * @param {string} pApplyChange - If "0", the change will not be applied.
	 * @param {string} [pCSSSelector] - Optional. If provided, the color will be applied to the closest element matching this selector instead of the input itself.
	 * @param {string} [pElementIDPrefix] - Optional. The prefix for the tabular element ID. Default is 'TABULAR-DATA-'.
	 * @returns {boolean} - Returns true if the color was applied successfully or if the change was skipped for pApplyChange equal to "0", false otherwise.
	 */
	colorInputBackgroundTabular(pSectionHash, pGroupHash, pInputHash, pRowIndex, pColor, pApplyChange, pCSSSelector, pElementIDPrefix = 'TABULAR-DATA-')
	{
		if (pApplyChange == "0")
		{
			return true;
		}

		/** @type {import('../views/Pict-View-DynamicForm.js')} */
		let tmpInputView = this.pict.views.PictFormMetacontroller.getSectionViewFromHash(pSectionHash);

		if (!tmpInputView)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInputBackgroundTabular could not find input with section hash [${pSectionHash}] group hash [${pGroupHash}] input hash [${pInputHash}].`);
			return false;
		}

		let tmpInput = tmpInputView.getTabularRecordInputByHash(pGroupHash, pInputHash);

		if (!tmpInput)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInputBackgroundTabular could not find input with section hash [${pSectionHash}] group hash [${pGroupHash}] input hash [${pInputHash}].`);
			return false;
		}

		if (!tmpInput.Macro)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInputBackgroundTabular input with section hash [${pSectionHash}] group hash [${pGroupHash}] input hash [${pInputHash}] is missing Macro data.`);
			return false;
		}

		//FIXME: is this reliable for all input types?
		let tmpElementSet = this.pict.ContentAssignment.getElement(`#${pElementIDPrefix}${tmpInput.Macro.RawHTMLID}-${pRowIndex}`);

		if (tmpElementSet.length < 1)
		{
			this.log.warn(`PictDynamicFormsInformary: colorInputBackgroundTabular could not find input element with section hash [${pSectionHash}] group hash [${pGroupHash}] input hash [${pInputHash}] row index [${pRowIndex}] selector [#${tmpInput.Macro.RawHTMLID}-${pRowIndex}].`);
			return false;
		}

		return this.colorElementBackground(tmpElementSet, pColor, pCSSSelector);
	}

	/**
	 * @param {Array<HTMLElement>} pElementSet - The element to color.
	 * @param {string} pColor - The HTML hex color to apply (e.g. #FF0000 for red).
	 * @param {string} [pCSSSelector] - Optional. If provided, the color will be applied to the closest element matching this selector instead of the input itself.
	 *
	 * @returns {boolean}
	 */
	colorElementBackground(pElementSet, pColor, pCSSSelector)
	{
		/** @type {HTMLElement} */
		let tmpElement = pElementSet[0];

		// if we passed a class target, find the closest element with that class and apply the color to it
		// otherwise, just apply it to the input element itself
		if (pCSSSelector)
		{
			// find closest target by class name and if we find it, immediately break out of the loop
			for (let i = 0; i < pElementSet.length; i++)
			{
				const element = pElementSet[i];
				const closest = element.closest(`${pCSSSelector}`);
				if (closest && closest instanceof HTMLElement)
				{
					tmpElement = closest;
					break;
				}
			}
		}

		tmpElement.style.backgroundColor = pColor;

		return true;
	}

	logValues()
	{
		let tmpLastValue = null;
		let tmpLogLine = 'Solver logvalues call: ';
		for (let i = 0; i < arguments.length; i++)
		{
			tmpLastValue = arguments[i];
			tmpLogLine += `  [${i}]=[${tmpLastValue}]`;
		}
		this.log.info(tmpLogLine);
		return tmpLastValue;
	}
}

module.exports = PictDynamicFormsSolverBehaviors;
module.exports.default_configuration = _DefaultProviderConfiguration;
